TODO List for Mosml-llvm

* Setup a toolset for benchmark runs.
   Has to be thought out, but I would like to be able to:

   ; Benchmark multiple SML compilers
   ; Benchmark their performance movement over time
   ; Keep track of old benchmark results in a simple format.
   ; Be able to plot results over time
   ; Use geometric mean for a final number.

- Current-build Ex-SML compiler driver
- Installed Ex-SML compiler driver
- MLton compiler driver
- JSON output
   Make the system output JSON data


o [jlouis] Change the buildsystem to use -toplevel builds all the way through.
   Many things w.r.t clean code depends on this being done.

* Consider making -toplevel the default buildmode.

* 2003 Basis implementation:

   These things still needs to be done. Done in this case means that
   you can sometimes check that the current library is correct w.r.t
   2003 and then you can remove it from this list. Sometimes you can
   implement missing functionality to get it to 2003. A few cases
   requires some deep deep runtime/compiler fu to get right as it is
   deep inside the system. Most notably I/O.

   ArraySlice :> ARRAY_SLICE
     Needs vectorslices for copyVec

   BinIO :> BIN_IO
   BinPrimIO :> PRIM_IO

   Byte :> BYTE
     Byte needs Word8ArraySlices

   CharArray :> MONO_ARRAY
   CharArraySlice :> MONO_ARRAY_SLICE
     Seriously needs -toplevel

   Char :> CHAR
     Needs an implementation of scan

   CharVector :> MONO_VECTOR
   CharVectorSlice :> MONO_VECTOR_SLICE
   CommandLine :> COMMAND_LINE
   Date :> DATE
   General :> GENERAL
   IEEEReal :> IEEE_REAL
   Int :> INTEGER
   IO :> IO
   LargeInt :> INTEGER
   LargeReal :> REAL
   LargeWord :> WORD
   List :> LIST
   Math :> MATH
   Option :> OPTION
   OS :> OS
   Position :> INTEGER
   Real :> REAL
   StringCvt :> STRING_CVT
   String :> STRING
   Substring :> SUBSTRING
   TextIO :> TEXT_IO
   TextPrimIO :> PRIM_IO
   Text :> TEXT
   Timer :> TIMER
   Time :> TIME
   VectorSlice :> VECTOR_SLICE
   Vector :> VECTOR
   Word8Array :> MONO_ARRAY
   Word8ArraySlice :> MONO_ARRAY_SLICE
   Word8Vector :> MONO_VECTOR
   Word8VectorSlice :> MONO_VECTOR_SLICE
   Word8 :> WORD
   Word :> WORD

o [jlouis] Make some tests of the Array/ArraySlice 2003 basis
   The current tests are quite incomplete and does not test that Array
   and ArraySlice have correctly implemented functions. Hence we will
   fix it by writing a large set of tests that can test the
   cornercases of these functions.

* Upgrade make system and fix it.
   Things that can be done:

- Install targets
   Provide correct install targets for everything. This is seriously
   lacking at the moment.
- Bump bootstrap target
   Provide a way to make the current compiler/linker/toplevel into the
   new bootstrap compiler/linker/toplevel. It only has to be done on a
   flag-day, but it is important to support this kind of
   bootstrapping.
- Support top_builddir
   We have been using top_srcdir in a lot of places where it should
   have been top_builddir. Correcting this lets you compile the code
   in a place separate from the place where you have the source
   code. Some buildsystems does exactly that, so supporting it is
   important.

* Make failwith() not return!
   By marking it as notreturn we have a better encoding.

* Make the IntInf work
   First, hoist it out of dynlib. Since we are MUST have
   LargeInt == IntInf if IntInf is present, and LargeInt is
   non-optional, we are forced to always provide IntInf. Hence there
   is little reason for having it in a dynlib structure.

   Next, use IntInf constrained to INTEGER to provide LargeInt.

* Implement OS.Process.sleep
   Easy task. Add a new primitive, convert the time to something the
   backend can process and fire it down to the lower level. Since the
   system is not threaded at all it is not that hard to get to succeed
   at the moment.

* Implement OS.errorName and OS.syserror
   Getting these right in a portable way is pretty nasty. So please,
   before you do the task think hard on circumventing a a big switch
   in the world of C. Clever conversion routines would be preferable.

* Add testcases for ListPairs -Eq functions.
   Since the tests are ooold, there are no tests for the -Eq
   functions. This ought to be remedied.

o [jlouis] Make String 2003 Basis
   Update String to 2003 Basis

- Write test cases for isSubstring

- Implement and write test cases for String.scan

o [jlouis] Mail John H. Reppy
   We need to get a resolution w.r.t String.fromString and how
   scanning should work. It is not at all clear from the specification
   how it is supposed to work, so I need the formal clarification
   behind the scanning and how it is supposed to work.

   Relevant test cases:

   ; The inversion of test 20 and test 24 in string.sml

   ; The string.fromString.sml test case

* Update tools/mosmldep
   This tool currently looks like a fastcoded mess. Cleaning it up
   would be beneficial. Also remember to kill its output of trailing
   whitespace in the process.

   It might be the case you want to wait until we have a bit more
   Filesystem utils in the standard library at our discretion.

* Make Time correct (depends on IntInf)
   Time is required to produce LargeInt.int types all over, so this
   should be fixed.

* Analyze the need to redefine how signatures and structures work
   Currently there are some odd rules w.r.t signatures and structures
   because the way we search for .ui and .uo files. This can probably
   be removed once we begin to run with LLVM.

   The problem is that you can't sometimes have a signature at
   top-level inside a .sml file. And you can't have a top level
   structure with a name different from the file name.

   I don't like the idea of using the file name to find modules.

   This task is to analyze:

   ; What is going on?
   ; Is there a sensible way to get around it?
   ; Eventually devise a fix.

* DYNLIB: Do .so visibility right

* Clean up C code for warnings
   There are plenty. Cleaning them away is important.

* Implement more tracing routines.
   Easy task and quite effective when debugging the bytecode backend.

* COPYING:
   We need the license mess to be sorted out. The current plan is to
   keep the compiler proper as a GPL project, but get the backend to
   use an INRIA-friendly license. Goals:

   ; Produce a piece of software that can be used for commercial
   projects without you having to virally give away your source
   code. Preferably LGPL the runtime.

   ; Protect the compiler itself with GPLv2. I prefer it be kept as a
   project in the public scrutiny.

   ; Make the system obey the Debian Free Software Guidelines. If we
   are inside the limits of DFSG, we are at the right place.

   Carrying out this is a bit of lobbying work. Ultimately it is about
   knowing where we stand and having a frame we work inside. If the
   runtime can't be "liberated" into DFSG limits, then we'll have to
   rewrite it and our general plan has to change.

* Write the type checker for LLVM function calls.
   This will take some time, but it is doable with some hard work.
   You just need to be aware of the little details in the game.

- Finish the typechecker
   There are still some loose ends with instructions.

- Clean up LLVM misconceptions
   There are some misconceptions between constant expressions and
   instructions regarding type checking in LLVM. These must be sorted
   out with the LLVM people.

* Eradicate the Not_Implemented in LLVM.sml
   This means a full implementation of LLVM.


* Set up buildbot

* Rewrite documentation

* Begin figuring out how to fix, mix, and match Lambda with LLVM
* Get benchmarks from MLton added

* Lambda seems to be compilable down to code
* Check the ocaml system. Code and documentation!


