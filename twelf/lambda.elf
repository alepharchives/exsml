%%*** The Lambda language of Moscow ML
%%% Lambda language, main.

%% Introduce lambda expressions of natural numbers
exp : type. %name exp E.
exp-list : type. %name exp-list EL.

exp/scon : scon -> exp.
exp/lambda : (exp -> exp) -> exp.
exp/letrec : (exp -> exp) -> exp.
exp/apply  : exp -> exp -> exp.
exp/if : exp -> exp -> exp -> exp.
exp/seq : exp -> exp -> exp.
exp/andalso : exp -> exp -> exp.
exp/orelse : exp -> exp -> exp.
exp/unspec : exp.
exp/while : exp -> exp -> exp.
exp/prim : primitive -> exp-list -> exp.

exp-list/nil : exp-list.
exp-list/cons : exp -> exp-list -> exp-list.

%% Shortcuts for later work, should probably be moved to somewhere else.
v_true = (exp/scon (scon/bool true)).
v_false = (exp/scon (scon/bool false)).

%% Value
value : exp -> type.
value/scon : value (exp/scon _).
value/lambda : value (exp/lambda [x] E x).

%% Primitive evaluation contexts. This defines a context which is static while
%%  evaluation happens "in the hole" (which is a lambda en this game :)
pctx : (exp -> exp) -> type.

pctx/apply-1 : pctx ([x] exp/apply x E2).
pctx/apply-2 : pctx ([x] exp/apply V x)
		<- value V.

pctx/seq1 : pctx ([x] exp/seq x E2).

%% Introduce a (small-step) evaluation form
step : exp -> exp -> type.

step/ctx : step (EC E) (EC E')
	    <- pctx EC
	    <- step E E'.

step/app-lam : step (exp/apply (exp/lambda [x] E1' x) V2) (E1' V2)
		<- value V2.
step/letrec : step (exp/letrec [x] E x) (E (exp/letrec [x] E x)).
step/seq : step (exp/seq V E2) E2
	    <- value V.

%{
ev/scon : ev (exp/scon SC) (exp/scon SC).
ev/lambda : ev (exp/lambda [x] E x) (exp/lambda [x] E x).
ev/apply : ev (exp/apply L V) R
	    <- ev L (exp/lambda [x] E x)
	    <- ev V V'
	    <- ev (E V') R.
ev/if/t : ev (exp/if Test True False) T'
	   <- ev Test v_true
	   <- ev True T'.
ev/if/f : ev (exp/if Test True False) F'
	   <- ev Test v_false
	   <- ev False F'.


%% Evaluation always ends in a canonical form and its proof.
ev-has-canonical-form : ev E E' -> canonical-form E' -> type.
%mode ev-has-canonical-form +E -CF.
- : ev-has-canonical-form (ev/scon _) canonical-form/scon.
- : ev-has-canonical-form ev/lambda canonical-form/lambda.
- : ev-has-canonical-form (ev/apply D3 D2 D1) CF
     <- ev-has-canonical-form D3 CF.
- : ev-has-canonical-form (ev/if/t TrueC Test) X
     <- ev-has-canonical-form TrueC X.
- : ev-has-canonical-form (ev/if/f FalseC Test) X
     <- ev-has-canonical-form FalseC X.

%worlds () (ev-has-canonical-form _ _).
%total E (ev-has-canonical-form E _).

of : exp -> ty -> type.

of/scon : of (exp/scon SC) (ty/scon TSC)
	   <- of-scon SC TSC.
of/apply : of (exp/apply E1 E2) T2
	    <- of E1 (ty/arrow T1 T2)
	    <- of E2 T1.
of/lambda : of (exp/lambda [x] E x) (ty/arrow T T')
	     <- ({x : exp} of x T
		   -> of (E x) T').
of/if : of (exp/if Test True False) T
	 <- of Test ty/bool
	 <- of True T
	 <- of False T.


%% Type preservation
ty_preserv : ev E E' -> of E T -> of E' T -> type.
%mode ty_preserv +EV +TP1 -TP2.
- : ty_preserv ev/nat of/nat of/nat.
- : ty_preserv ev/bool of/bool of/bool.
- : ty_preserv ev/lambda (of/lambda E) (of/lambda E).
- : ty_preserv (ev/apply D3 D2 D1) (of/apply T2 T1) T3'
     <- ty_preserv D1 T1 (of/lambda T1')
     <- ty_preserv D2 T2 T2'
     <- ty_preserv D3 (T1' V2 T2') T3'.
- : ty_preserv (ev/if/t TrueC Test) (of/if DFalse DTrue DTest) T
     <- ty_preserv TrueC DTrue T.
- : ty_preserv (ev/if/f FalseC Test) (of/if DFalse DTrue DTest) T
     <- ty_preserv FalseC DFalse T.

%worlds () (ty_preserv _ _ _).
%total E (ty_preserv E _ _).

%% Type progression

progression : exp -> type.
progression/canonical : progression E
			 <- canonical-form E.
progression/step : progression E'
		    <- ev E E'.

ty_progress : ev E E' -> of E T -> progression E -> type.
- : ty_progress ev/nat of/nat (progression/canonical canonical-form/nat).
- : ty_progress ev/bool of/bool (progression/canonical canonical-form/bool).
- : ty_progress ev/lambda (of/lambda _) (progression/canonical canonical-form/lambda).


- : ty_progress (ev/if/t ETrue ETest) (of/if TFalse TTrue TTest) P
     <- ty_progress ETrue TTrue P.
- : ty_progress (ev/if/f EFalse ETest) (of/if TFalse TTrue TTest) P
     <- ty_progress EFalse TFalse P.
}%



