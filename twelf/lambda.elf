%%*** The Lambda language of Moscow ML

%% We present the Lambda language in HOAS style rather than in
%%  De-Bruijn-indexing. I really hope there is a rather simple way to
%%  convert the following development into a De-Bruijn indexed variant
%%  while preserving the types.

%% Introduce a very simple type system (for now)
tp : type. %name tp T.
tp/unit : tp.
tp/bool : tp.
tp/nat : tp.
tp/char : tp.
tp/arrow : tp -> tp -> tp.

%% Special Constructors. These are nat, char, word, string, etc and
%%  represent these in the backend.
scon : type. %name scon SC.

scon/nat : nat -> scon.
scon/char : nat -> scon.
scon/bool : bool -> scon.
scon/unit : scon.
%% ... There are more here, but we don't need it. We only need enough
%% to show that the type system is safe and thus we can utilize a
%% small set of Scons to show this.

%% Introduce lambda expressions of natural numbers
exp : tp -> type. %name exp E.
exp-list : type. %name exp-list EL.

exp-list/nil : exp-list.
exp-list/cons : exp T -> exp-list -> exp-list.

exp/scon : scon -> exp T.
exp/lambda : (exp T -> exp T') -> exp (tp/arrow T T').
exp/letrec : (exp T -> exp T) -> exp T.
exp/let : exp T -> (exp T -> exp T') -> exp T'.
exp/apply  : exp (tp/arrow T T') -> exp T -> exp T'.
exp/if : exp T -> exp T -> exp T -> exp T.
exp/seq : exp T -> exp T -> exp T.
exp/andalso : exp T -> exp T -> exp T.
exp/orelse : exp T -> exp T -> exp T.
exp/unspec : exp T.
exp/while : exp T -> exp T -> exp T.
exp/prim : primitive -> exp-list -> exp T.

%% Shortcuts for later work, should probably be moved to somewhere else.
v_true = (exp/scon (scon/bool true)).
v_false = (exp/scon (scon/bool false)).
v_unit = (exp/scon scon/unit).

%% Values in the language.
value : exp T -> type.
value/scon : value (exp/scon _).
value/lambda : value (exp/lambda [x] E x).

%% Primitive evaluation contexts. This defines a context which is
%%  static while evaluation happens "in the hole" (which is a lambda
%%  in this game :) I first saw this idea when it was presented by
%%  Andrzej Filinski in a Twelf-course.  The cleverness is that we
%%  split "boring" evaluation from where the real stuff happens.
pctx : (exp T -> exp T') -> type.

pctx/apply-1 : pctx ([x : exp (tp/arrow T1 T2)] exp/apply x E2).
pctx/apply-2 : pctx ([x : exp (tp/arrow T1 T2)] exp/apply V x)
		<- value V.

pctx/seq-1 : pctx ([x] exp/seq x E2).

pctx/if-tst : pctx ([x] exp/if x T F).
pctx/andalso-1 : pctx ([x] exp/andalso x E2).
pctx/orelse-1  : pctx ([x] exp/orelse x E2).
pctx/let       : pctx ([x] exp/let x B).

%% Introduce a (small-step) evaluation form
step : exp T -> exp T -> type.
%% Primitives are evaluated by this rule.
ev-primitive : primitive -> exp-list -> exp T -> type.

step/ctx : step (EC E) (EC E')
	    <- pctx EC
	    <- step E E'.

step/app-lam : step (exp/apply (exp/lambda [x] E1' x) V2) (E1' V2)
		<- value V2.
step/letrec : step (exp/letrec [x] E x) (E (exp/letrec [x] E x)).
step/let : step (exp/let L ([x] B x)) (B L)
	    <- value L.

step/seq : step (exp/seq V E2) E2
	    <- value V.
step/if-t : step (exp/if v_true T _) T.
step/if-f : step (exp/if v_false _ F) F.
step/andalso-1 : step (exp/andalso v_true E2) E2.
step/andalso-2 : step (exp/andalso v_false _) v_false.
step/orelse-1  : step (exp/orelse v_true _) v_true.
step/orelse-2  : step (exp/orelse v_false E2) E2.

step/while : step (exp/while T B) (exp/if T (exp/seq B (exp/while T B)) v_unit).

step/primitive : step (exp/prim P EL) R
		  <- ev-primitive P EL R.

%% Iterated step relation for completeness
steps : exp T -> exp T -> type.

steps_0 : steps E E.

steps_s : steps E E'
	   <- step E E''
	   <- steps E'' E'.

stepsto : exp T -> exp T -> type.

sto_do : stepsto E V
	  <- steps E V
	  <- value V.

%{
%% Evaluation always ends in a canonical form and its proof.
ev-has-canonical-form : ev E E' -> canonical-form E' -> type.
%mode ev-has-canonical-form +E -CF.
- : ev-has-canonical-form (ev/scon _) canonical-form/scon.
- : ev-has-canonical-form ev/lambda canonical-form/lambda.
- : ev-has-canonical-form (ev/apply D3 D2 D1) CF
     <- ev-has-canonical-form D3 CF.
- : ev-has-canonical-form (ev/if/t TrueC Test) X
     <- ev-has-canonical-form TrueC X.
- : ev-has-canonical-form (ev/if/f FalseC Test) X
     <- ev-has-canonical-form FalseC X.

%worlds () (ev-has-canonical-form _ _).
%total E (ev-has-canonical-form E _).

of : exp -> ty -> type.

of/scon : of (exp/scon SC) (ty/scon TSC)
	   <- of-scon SC TSC.
of/apply : of (exp/apply E1 E2) T2
	    <- of E1 (ty/arrow T1 T2)
	    <- of E2 T1.
of/lambda : of (exp/lambda [x] E x) (ty/arrow T T')
	     <- ({x : exp} of x T
		   -> of (E x) T').
of/if : of (exp/if Test True False) T
	 <- of Test ty/bool
	 <- of True T
	 <- of False T.


%% Type preservation
ty_preserv : ev E E' -> of E T -> of E' T -> type.
%mode ty_preserv +EV +TP1 -TP2.
- : ty_preserv ev/nat of/nat of/nat.
- : ty_preserv ev/bool of/bool of/bool.
- : ty_preserv ev/lambda (of/lambda E) (of/lambda E).
- : ty_preserv (ev/apply D3 D2 D1) (of/apply T2 T1) T3'
     <- ty_preserv D1 T1 (of/lambda T1')
     <- ty_preserv D2 T2 T2'
     <- ty_preserv D3 (T1' V2 T2') T3'.
- : ty_preserv (ev/if/t TrueC Test) (of/if DFalse DTrue DTest) T
     <- ty_preserv TrueC DTrue T.
- : ty_preserv (ev/if/f FalseC Test) (of/if DFalse DTrue DTest) T
     <- ty_preserv FalseC DFalse T.

%worlds () (ty_preserv _ _ _).
%total E (ty_preserv E _ _).

%% Type progression

progression : exp -> type.
progression/canonical : progression E
			 <- canonical-form E.
progression/step : progression E'
		    <- ev E E'.

ty_progress : ev E E' -> of E T -> progression E -> type.
- : ty_progress ev/nat of/nat (progression/canonical canonical-form/nat).
- : ty_progress ev/bool of/bool (progression/canonical canonical-form/bool).
- : ty_progress ev/lambda (of/lambda _) (progression/canonical canonical-form/lambda).


- : ty_progress (ev/if/t ETrue ETest) (of/if TFalse TTrue TTest) P
     <- ty_progress ETrue TTrue P.
- : ty_progress (ev/if/f EFalse ETest) (of/if TFalse TTrue TTest) P
     <- ty_progress EFalse TFalse P.
}%



