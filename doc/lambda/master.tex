\documentclass[a4paper, oneside, 10pt, draft]{memoir}
\input{packages}
\chapterstyle{culver}
\usepackage{fixme}
\usepackage{coqdoc}
\usepackage[english]{babel}
%\usepackage[utopia]{mathdesign}

\usepackage[osf,sc]{mathpazo}
\linespread{1.05}
%\usepackage{fourier}


\usepackage{semantic}
\author{Jesper Louis
  Andersen\\jesper.louis.andersen@gmail.com\\140280-2029}
\title{Lambda}
\date{\today}

\newlength{\drop}
\newcommand*{\titleM}{\begingroup% Misericords, T&H p 153
  \drop = 0.08\textheight
  \centering
  {\Huge\bfseries Lambda}\\[\baselineskip]
  {\scshape IR of exsml}\\[\baselineskip]
  {\scshape by}\\[\baselineskip]
  {\large\scshape Jesper Louis Andersen\\jesper.louis.andersen@gmail.com}\par
  \endgroup}

\bibliographystyle{plain}

\begin{document}
\newcommand{\janusz}{$\mathrm{JANUS}_0$}
\newcommand{\januso}{$\mathrm{JANUS}_1$}
\newcommand{\lift}[1]{\lfloor #1 \rfloor}
\newcommand{\NN}{\mathbb{N}}
\newcommand{\ZZ}{\mathbb{Z}}
\titleM{}
\begin{abstract}
This document describes the Lambda language used as an intermediate
representation in Moscow ML, ExSML and in Caml Light. It also forms
the basis for Ocaml in a changed form.
\end{abstract}
\listoffixmes
%\tableofcontents
\chapter{Introduction}
This document describes the Lambda-language which is the internal
representation of Moscow ML and ExSML. It is based upon a similar
language in the Ocaml system, although a number of changes has been
made to accomodate SML-specifics.

\chapter{Lambda}

Lambda is an extended lambda-calculus, much like most functional
programming languages use as a basis. By extended, we means that the
language has the lambda-calculus as its base but has been augmented
with additional constructs making certain operations more viable. As
an example, you can define Peano-arithmetic in the pure lambda
calculus -- but this construction is hardly efficient. In Lambda,
integers are provided as a primitive, yielding fast arithmetic. Also,
it is easier to map fast arithmetic down to the underlying machine.

To circumvent problems with alpha-conversion in the traditional
Lambda-calculus, the Lambda language uses De-Bruijn indexing all
over. With De-Bruijn indexing, machine manipulation is easy although
it is harder to read for a human being.

Lambda also contains while-loops and sequencing effectively making
the language into an ``algorithmic functional language''. Contrast with
a pure functional language in which there are no imperative constructs
at all.

First, we introduce some data types used in the Lambda language:

\section{Special Constructors}

To facilitate the inclusion of integers, reals, strings, words and
characters in the Lambda language, we use the concept of a
\emph{Special Constructor} (SCon). An SCon is a constructor in the
traditional sense from a datatype, but it is special in the sense it
is used for primitive values. In the backend a Special constructor
is encoded as a \texttt{value}.

Note that the Lambda definition uses an \texttt{StructConstant} as the
constant container rather than an SCon. This is also the reason SCons
are often called Atoms. We will cover StructConstants
later.\fixme{Cover StructConstants Later :)}

\section{BlockTags}

A BlockTag is really a pair of a tag number and a span, embedded in a
\texttt{CONtag} constructor. The tag number is used as a discriminator
so different blocktags can be distinguished from each other. The span
records how many different tag numbers there are in the datatype. For
example, the values ``false'' and ``true'' are encoded as $(0,2)$ and
$(1,2)$ respectively. They are members of a special datatype, bool.

This information is utilized by the pattern match compiler. It knows
when it has outruled the possibility of a match on $span-1$ then it
\emph{must} be the final value. Note that the tag number is not unique
over all different datatypes. We know, due to static type checking
that different tag numbers can not possibly intermingle.

\section{Syntax}

The syntax for the lambda language is as follows:

\newcommand{\ssplit}{\;\vert\;}
\reservestyle{\command}{\mathbf}
\command{let[\;let\;],in[\;in\;],end[\;end\;],case[\;case\;],of[\;of\;],letrec[\;letrec\;],
switch[\;switch],handle[\;handle\;],shandle[\;shandle\;],sfail[\;sfail\;],if[\;if\;],
then[\;then\;],else[\;else\;],shared[\;shared],while[\;while\;],andalso[\;andalso\;],
orelse[\;orelse\;]}
\begin{align*}
  e ::= \quad & \; n \ssplit sc \ssplit e \; (e_1 \; \dotsc \; e_k) \ssplit \lambda
  (e) \ssplit \<let> (e_1 \; \dotsc \; e_k) \<in> e \<end> \ssplit \\
  & \<letrec> (e_1 \; \dotsc \; e_k) \<in> e \<end> \ssplit
  \{p\}(e_1, \dotsc, e_k) \ssplit\\
  & \<case> e \<of> sc_1 \Rightarrow e_1, \; sc_2 \Rightarrow e_2, \;
  \dotsc \ssplit\\
  & \<switch>(a)\; e \<of> bt_1 \Rightarrow e_1, \; bt_2
  \Rightarrow e_2, \; \dotsc \ssplit \\
  & \<sfail> \ssplit e_1 \<shandle> e_2 \ssplit e_1 \<handle> e_2
  \ssplit \\
  & \<if> e_{tst} \<then> e_{true} \<else> e_{false} \ssplit e_1; \; e_2
  \ssplit \\
  & \; e_t \<while> e \ssplit e \<andalso> e \ssplit e \<orelse> e
  \ssplit unspec \\
  & \<shared>(k) \; e^{*} 
\end{align*}
\begin{description}
\item[$n$] A number $n$ refers to the $n$'th enclosing lambda in the
  scope. This is the De-Bruijns indexing on the lambda calculus. That
  is, the $n$ is a natural number referring to a lambda-binder.
\item[$sc$] The $sc$ refers to any special constructor. Special
  constructors are integers, strings, reals, and so on. They are
  manipulated by using primitive calls. As an example, there is a
  primitive call of arity two which can add integers. Similarly there
  are primitives for string concatenation and so on. In fact all
  operations on structconstants are done by primitives.
\item[$e \; (e_1 \; \dotsc \; e_k) $] Function application in strict
  order. First, $e_1$ through $e_k$ are executed (in that order) and
  when they are reduced to canonical forms they are applied to $e$ in
  order. It is expected that $e$ is a series of lambdas so we can
  apply the arguments.

\end{description}
\end{document}
